\chapter{Проектирование архитектуры программного комплекса}
\section{Общая архитектура системы}

Разрабатываемая система представляет собой микросервисный программный комплекс, построенный по гибридной архитектуре. В качестве основного паттерна проектирования выбран «Backend For Frontend» (BFF) в реализации API Gateway.
Архитектура системы включает следующие логические слои:
\begin{enumerate}
	\item \textit{Слой клиента.} Внешние потребители (веб-браузеры, мобильные приложения), взаимодействующие с системой посредством языка запросов GraphQL.
	\item \textit{Слой агрегации (API Gateway).} Единая точка входа для запросов к системе.
	\item \textit{Слой микросервисов.} Набор автономных сервисов, реализующих бизнес-логику и взаимодействующих друг с другом посредством бинарного протокола gRPC.
	\item \textit{Слой хранения данных.} Изолированные H2 in-memory базы данных для каждого микросервиса (паттерн Database per Service).
	
\end{enumerate}
\section{Описание компонентов системы}
\subsection{Сервис API Gateway}
Компонент, реализованный на базе Spring for GraphQL. Он не содержит собственной бизнес-логики и персистентных данных, выполняя роль оркестратора.
Ключевые функции шлюза:
\begin{itemize}
	\item Парсинг входящих GraphQL-запросов и валидация схемы.
	\item Определение необходимых источников данных для выполнения запроса (Data Fetching).
	\item Управление пулом gRPC-каналов (Channel Pooling) для предотвращения блокировок на уровне HTTP/2 соединений.
	\item Агрегация ответов от микросервисов в единый JSON-документ.
\end{itemize}

Реализация сервиса содержит профили, позволяющие выбирать протокол общения (gRPC или REST).
\subsection{Микросервис «Каталог» (Catalog Service)}
Сервис отвечает за хранение и предоставление условно-статической информации о товарах. Поскольку операции чтения каталога создают наибольшую нагрузку на сеть, данный сервис спроектирован для передачи больших объемов данных.
Модель данных сервиса включает:
\begin{itemize}
	\item Идентификатор и наименование товара.
	\item Текстовое описание (Large Object), имитирующее «тяжелый» контент.
	\item Историю цен (массив числовых значений) для аналитики. Использование gRPC протокола позволяет сэкономить трафик за счёт эффективной кодировки числовых данных. 
\end{itemize}
\subsection{Микросервис «Склад» (Inventory Service)}
Сервис управляет динамической информацией о доступности товаров (stock). Cервис предоставляет интерфейс для получения остатков по списку идентификаторов товаров, что позволяет GraphQL подгружать информацию о количестве товара на складе о группе товаров сразу (из сервиса-каталога) за один запрос.  

\subsection{Проектирование протоколов межсервисного взаимодействия}
Ключевым аспектом разработанной архитектуры является возможность отказа от текстовых контрактов (JSON) во внутреннем контуре системы в пользу бинарных протоколов со строгой типизацией. Взаимодействие между компонентами спроектировано на основе подхода Schema-First, где первичным артефактом является спецификация интерфейса.

Для обеспечения согласованности данных между микросервисами используется язык описания интерфейсов Protocol Buffers. Это решение позволяет абстрагироваться от деталей реализации конкретных сервисов и сосредоточиться на структуре передаваемых данных.

Использование protobuff в проекте решает следующие архитектурные задачи:
\begin{itemize}
	\item \textit{Гарантия целостности типов.} Контракт жестко определяет типы данных (числа, строки, списки), исключая ошибки парсинга, характерные для слаботипизированных JSON-структур.
	\item \textit{Кодогенерация.} Клиентские библиотеки и серверные заглушки генерируются автоматически на основе .proto контрактов, что исключает любые расхождения между реализациями API в сервисах.
\end{itemize}

Реализация системы позволяет также переключаться между форматом JSON (для REST) и protobuff (для gRPC), что позволяет проводить различные тестирования нагрузок.
\section{Механизм управления соединениями}
Одной из ключевых проблем при использовании gRPC в высоконагруженных Java-приложениях является ограничение мультиплексирования HTTP/2. При использовании единственного канала множество параллельных запросов выстраиваются в очередь, что нивелирует преимущества протокола.

В рамках проектирования системы был разработан механизм клиентской балансировки на стороне API Gateway. Вместо одного канала создается пул управляемых каналов (channel pool). Это позволяет линейно масштабировать пропускную способность межсервисного взаимодействия.

\section{Технологический стек реализации}
Для реализации \cite{github-source-code} спроектированной архитектуры выбран следующий стек технологий:
\begin{itemize}
	\item Язык программирования: Java 25. 
	\item Экосистема: Spring (Boot 4.0). Обеспечивает быструю конфигурацию и профилирование микросервисов, отслеживание зависимостей и интеграцию с Spring gRPC.
	\item gRPC реализация: Spring gRPC Starter. Используется для внедрения gRPC-серверов и клиентов в контекст Spring.
	\item Слой данных: Spring Data JPA (Hibernate) и in-memory база данных H2.
	\item Система сборки: Gradle с использованием мульти-модульной структуры проекта для совместного использования proto-контрактов.
\end{itemize}
\section{Вывод к Главе 2}
В рамках данной главы было выполнено проектирование архитектуры программного комплекса, предназначенного для исследования эффективности обработки запросов в высоконагруженных системах электронной коммерции.

Разработанная гибридная архитектура, основанная на паттерне Backend For Frontend (API Gateway), объединяет преимущества декларативной выборки данных (GraphQL) на стороне клиента и высокопроизводительного бинарного взаимодействия (gRPC) внутри контура микросервисов. Такой подход направлен на минимизацию сетевого трафика и устранение проблем избыточности данных (over-fetching) и недостатка данных (under-fetching), характерных для REST-архитектур.

Применение подхода Schema-First и формата Protocol Buffers обеспечило строгую типизацию контрактов между сервисами «Каталог» и «Склад», а также возможность эффективной передачи больших объемов структурированных данных (текстовых описаний и числовых массивов).

Выбранный технологический стек на базе Java и экосистемы Spring обеспечивает необходимую функциональность для реализации обоих протоколов взаимодействия (REST и gRPC), что позволяет перейти к практическому этапу исследования — проведению сравнительного нагрузочного тестирования, методика и результаты которого будут представлены в третьей главе.
%Спроектированная архитектура решает поставленные задачи за счет разделения ответственности: GraphQL обеспечивает гибкость выборки данных для клиента, решая проблем over-fetching и under-fetching "из-коробки", в то время как gRPC с использованием пула каналов и пакетных запросов обеспечивает максимальную производительность передачи данных внутри контура системы. Разделение контрактов в отдельный модуль гарантирует целостность данных и упрощает поддержку кодовой базы.