\chapter{Анализ архитектурных подходов к построению высоконагруженных систем электронной коммерции}
\section{Специфика нагрузки и требования к E-commerce системам}
Современные системы электронной коммерции функционируют в условиях высокой конкуренции, где время отклика приложения напрямую коррелирует с конверсией и выручкой. Исследования показывают, что задержка загрузки страницы даже на 100 миллисекунд может привести к снижению конверсии на 1-7\% \cite{akamai}.

Характерной чертой E-commerce приложений является неравномерный профиль нагрузки. Режим пиковых нагрузок возникает во время маркетинговых акций (например, «Черной пятницы») или сезонных распродаж. В такие периоды входящий трафик может возрастать на порядки за короткий промежуток времени.

С точки зрения паттернов доступа к данным, системы электронной коммерции относятся к классу read-heavy. Анализ поведения пользователей и трафика показывает, что операции чтения (просмотр каталога, поиск, фильтрация, открытие карточки товара, чтение отзывов) составляют до 95\% всей нагрузки на систему \cite{read-heavy}.

В микросервисной архитектуре, которая стала стандартом де-факто для крупных торговых площадок, обработка одного пользовательского запроса на чтение (например, «показать страницу товара») зачастую приводит к цепочке запросов (например, загрузке данных о товаре, отзывов и похожих товаров). Шлюз API (gateway) вынужден обращаться к множеству внутренних подсистем, отвечающих за нужную информацию. В условиях пиковой нагрузки эффективность межсервисного взаимодействия может стать узким местом всей системы.
\section{Анализ протокола REST и формата JSON}
Архитектурный стиль REST (Representational State Transfer) в сочетании с форматом сериализации JSON и протоколом HTTP/1.1 является наиболее распространенным стандартом для построения веб-сервисов. Его популярность обусловлена простотой отладки, человекочитаемостью формата и широкой поддержкой инструментов.

Однако в контексте высоконагруженных внутренних коммуникаций микросервисов данный подход имеет ряд существенных недостатков:
\begin{enumerate}
	\item \textit{Избыточность данных.} JSON является текстовым форматом. Передача числовых массивов (например, истории цен или аналитических метрик) и повторяющихся ключей полей в списках объектов приводит к значительному увеличению объема передаваемой информации (payload).
	\item \textit{Проблема блокировки .} В протоколе HTTP/1.1 для выполнения параллельных запросов требуется открытие множества TCP-соединений, что является ресурсоемкой операцией. В рамках одного соединения запросы выполняются последовательно, что может приводить к задержкам.
	\item \textit{Отсутствие строгой типизации.} REST не навязывает жесткого контракта интерфейса. Ошибки несовместимости типов данных между клиентом и сервером часто выявляются только на этапе выполнения, что снижает надежность системы.
\end{enumerate}
\section{Протокол gRPC как альтернатива для межсервисного взаимодействия}
Google Remote Procedure Cal (gRPC) — это высокопроизводительный фреймворк RPC (remote procedure call - удаленный вызов процедур), разработанный компанией Google. Он использует протокол HTTP/2 для транспорта и Protocol Buffers (Protobuf) в качестве языка описания интерфейсов (IDL - Interface Definition Language) и формата сериализации. 

Применение gRPC может решать ключевые проблемы, присущие подходу REST:
%% todo ссыдка на 3 главу?
\begin{itemize}
	\item \textit{Бинарная сериализация.} Protobuf кодирует данные в бинарный формат, также отказываясь от передачи имен полей (передаются только теги). В некоторых случаях это может позволить сократить размер сообщений в несколько раз по сравнению с JSON (см. Главу 3), что улучшает масштабируемость сервиса, а также устойчивость к нагрузкам.
	\item \textit{Мультиплексирование.} Протокол HTTP/2 позволяет передавать множество параллельных запросов и ответов в рамках одного TCP-соединения, устраняя необходимость в постоянном открытии и закрытии сокетов.
	\item \textit{Контрактный подход (Schema-First).} Разработка начинается с описания .proto файлов. Это гарантирует строгую типизацию и позволяет автоматически генерировать единый клиентский и серверный код, устраняя любые возможности различий в контрактах межсервисного общения.
\end{itemize}
К недостаткам gRPC можно отнести необходимость сериализации данных, что требует дополнительного процессорного времени и может не давать преимуществ по времени для запросов с малой или в основном текстовой полезной нагрузкой. 
\section{Роль GraphQL и партерна API Gateway}
Несмотря на преимущества gRPC для внутренней сети, его использование напрямую в браузерных клиентах не практикуется. Кроме того, остается проблема агрегации данных при использовании протокола REST. Необходимость сбора данных из разных сервисов приводит к тому, что клиенту нужно открывать несколько TCP-соединений для прогрузки данных одной страницы (проблема under-fetching). В других случаях REST запросы могут возвращать избыточную информацию (проблема over-fetching). Обе ситуации приводят к трате лишних ресурсов как сервера, так и клиента.

Паттерн API Gateway в сочетании с технологией GraphQL помогает решить эти проблемы "из коробки", выступая в роли единой точки входа для клиентских приложений. GraphQL позволяет клиенту декларативно описать требуемую структуру данных в одном запросе, беря ответственность за запросы к сервисам и формирование ответа на себя.

\section{Вывод к Главе 1}
Анализ требований к E-commerce системам показывает, что критическими метриками являются время отклика, что зачастую может определяться пропускной способностью межсервисной сети. Традиционный стек REST/JSON, обладая простотой, накладывает ограничения на производительность при передаче больших объемов структурированных данных.

Более эффективным решением может стать использование гибридной архитектуры, где GraphQL обеспечивает масштабируемость и гибкость разрабатываемого бэкенда, а gRPC используется для высокоскоростного обмена данными внутри защищенного контура кластера. В главе 2 описываются детали практической реализации данной архитектуры на платформе Java Spring. Глава 3 посвящена тестированию для сравнения скорости обработки запросов для протоколов gRPC и REST в различных сценариях.
%% Вспомогательные команды - Additional commands
%
%\newpage % принудительное начало с новой страницы, использовать только в конце раздела
%\clearpage % осуществляется пакетом <<placeins>> в пределах секций
%\newpage\leavevmode\thispagestyle{empty}\newpage % 100 % начало новой страницы