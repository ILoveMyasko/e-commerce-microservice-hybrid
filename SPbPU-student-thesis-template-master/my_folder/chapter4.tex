\chapter{Экспериментальные исследования и сравнительный анализ результатов}

В данной главе представлены спецификации и результаты тестирования разработанного программного комплекса. Целью экспериментов являлось сравнение производительности архитектурных подходов REST и gRPC при передаче больших объемов структурированных данных, характерных для E-commerce систем (списки товаров, история цен, текстовые описания).

\section{Методика проведения экспериментов}

Тестирование проводилось в трех различных сценариях для выявления зависимости производительности от пропускной способности сети и вычислительных ресурсов:

\begin{itemize}
	\item Анализ объема полезной нагрузки (payload): сравнение размера сериализованных данных в форматах JSON и Protocol Buffers.
	\item Идеальная сеть (localhost): тестирование с нулевой задержкой сети для оценки накладных расходов на сериализацию/десериализацию данных.
	\item Ограниченная сеть: измерение времени выполнения запросов для сети с ограниченной пропускной способностью (эмуляция перегрузки) с помощью инструмента Toxiproxy.
\end{itemize}

Для генерации нагрузки использовался инструмент \textit{Grafana k6}, эмулирующий одновременную работу виртуальных пользователей (virtual users). 

\section{Анализ эффективности сжатия данных}

В ходе первого этапа эксперимента сравнивался размер передаваемых данных при запросе списка из 1000 товаров. Каждый товар содержал текстовое описание (~500 байт) и массив истории цен (100 целочисленных значений), что типично для аналитических блоков E-commerce.

Результаты замеров размера полезной нагрузки представлены в Таблице \ref{tab:payload_comparison}.

\begin{table}[h!]
	\centering
	\caption{Сравнение размера полезной нагрузки (1000 товаров)}
	\label{tab:payload_comparison}
	\begin{tabular}{|l|c|c|c|}
		\hline
		\textbf{Формат данных} & \textbf{Размер (KB)} & \textbf{Относительный размер} & \textbf{Экономия трафика} \\ \hline
		REST (JSON) & 780.5 & 100\% & — \\ \hline
		gRPC (Protobuf) & 455.2 & 58.3\% & 41.7\% \\ \hline
	\end{tabular}
\end{table}

\textbf{Анализ:} Использование формата Protocol Buffers позволило сократить объем передаваемых данных на 41.7\%. Основной выигрыш был достигнут за счет использования механизма \textit{Packed Encoding} для числовых массивов (история цен), где JSON вынужден передавать каждый элемент как строку с разделителями. Текстовые поля показали меньшую степень сжатия, так как кодировка UTF-8 идентична для обоих форматов.

\section{Результаты нагрузочного тестирования}

\subsection{Сценарий «Идеальная сеть» (Localhost)}

В данном сценарии сеть не являлась узким местом. Тест проводился для оценки накладных расходов (Overhead) на маппинг объектов и сериализацию в среде Java.
Параметры теста: 200 VUs, длительность 30 секунд.

\begin{table}[h!]
	\centering
	\caption{Метрики времени отклика (Latency) в локальной среде, мс}
	\label{tab:localhost_results}
	\begin{tabular}{|l|c|c|c|c|}
		\hline
		\textbf{Протокол} & \textbf{Avg} & \textbf{Min} & \textbf{Max} & \textbf{p95} \\ \hline
		REST & 24.5 & 12.1 & 145.2 & 38.4 \\ \hline
		gRPC & 28.1 & 15.3 & 138.7 & 41.2 \\ \hline
	\end{tabular}
\end{table}

\textbf{Вывод:} В условиях отсутствия сетевых задержек показатели gRPC и REST сопоставимы. REST показал незначительное преимущество (около 13\% по среднему времени), что объясняется высокой оптимизацией JSON-сериализатора Jackson и отсутствием необходимости двойного преобразования объектов (Entity $\rightarrow$ Proto $\rightarrow$ DTO), которое выполняется в реализации gRPC.

\subsection{Сценарий «Ограниченная сеть» (Эмуляция 3G/4G)}

Данный сценарий является ключевым, так как имитирует реальные условия работы мобильных клиентов или перегруженной сети в дата-центре. С помощью Toxiproxy была установлена пропускная способность 200 KB/s на соединение.
Параметры теста: 20 VUs, настроен соответствующий пул каналов (channel pool) для gRPC во избежание блокировок HTTP/2.

\begin{table}[h!]
	\centering
	\caption{Метрики времени отклика при ограничении сети (200 KB/s), мс}
	\label{tab:network_limit_results}
	\begin{tabular}{|l|c|c|c|c|}
		\hline
		\textbf{Протокол} & \textbf{Avg} & \textbf{Min} & \textbf{Max} & \textbf{p95} \\ \hline
		REST & 3370 & 3320 & 3510 & 3400 \\ \hline
		gRPC & 1610 & 1570 & 2320 & 1660 \\ \hline
	\end{tabular}
\end{table}

\textbf{Анализ:} В условиях ограниченного канала связи архитектура на базе gRPC продемонстрировала двукратное (2.09x) превосходство по времени отклика.
Среднее время выполнения запроса для REST составило 3.37 с, в то время как для gRPC — 1.61 с.
Данный результат коррелирует с данными из Таблицы \ref{tab:payload_comparison}: уменьшение размера пакета в 2 раза привело к линейному уменьшению времени его передачи по сети.

\section{Влияние мультиплексирования и пула соединений}

В ходе предварительных тестов была выявлена проблема блокировки начала очереди (Head-of-Line Blocking) в gRPC при использовании единственного канала под высокой нагрузкой. Похожей проблемы для протокола REST не возникает, поскольку для каждого виртуального пользователя открывается отдельное TCP-соединение.
При 500 одновременных пользователях метрика p95 для gRPC возрастала до 416 мс (против 48 мс у REST).

Для решения этой проблемы был реализован механизм пула каналов (Channel Pooling) на стороне API Gateway. Распределение запросов по 10 независимым HTTP/2 соединениям позволило устранить очередь ожидания свободных стримов. После оптимизации метрика p95 стабилизировалась и стала зависеть исключительно от пропускной способности сети, как показано в Таблице \ref{tab:network_limit_results}.

\section{Выводы по главе}

Результаты экспериментов показывают, что эффективность бинарного протокола gRPC напрямую зависит от характеристик сетевой среды и структуры данных. 
\begin{enumerate}
	\item В локальной среде с высокой пропускной способностью накладные расходы на сериализацию Protobuf не дают выигрыша в производительности, зачастую это наоборот приводит к увеличенному времени ответа сервера.
	\item В условиях ограниченной пропускной способности сети, характерной для мобильных клиентов или высоконагруженных каналов, gRPC показывает лучшую устойчивость и масштабируемость, обеспечивая возможность эффективного сжатия (в 3 и более раза) числовых данных и заголовков ответов.
	\item Для эффективного использования gRPC в Java-приложениях с блокирующим I/O необходимо использование пула каналов для обхода ограничений мультиплексирования HTTP/2.
\end{enumerate}
%% Вспомогательные команды - Additional commands
%
%\newpage % принудительное начало с новой страницы, использовать только в конце раздела
%\clearpage % осуществляется пакетом <<placeins>> в пределах секций
%\newpage\leavevmode\thispagestyle{empty}\newpage % 100 % начало новой страницы